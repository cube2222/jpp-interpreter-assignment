-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module Language.Par where
import Language.Abs
import Language.Lex
import Language.ErrM

}

-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%name pTypeName_internal TypeName
%name pListTypeName_internal ListTypeName
%name pExpr6_internal Expr6
%name pExpr7_internal Expr7
%name pExpr5_internal Expr5
%name pExpr10_internal Expr10
%name pExpr2_internal Expr2
%name pFunctionParameter_internal FunctionParameter
%name pListFunctionParameter_internal ListFunctionParameter
%name pExpr9_internal Expr9
%name pListExpr_internal ListExpr
%name pExpr4_internal Expr4
%name pExpr3_internal Expr3
%name pExpr1_internal Expr1
%name pStmt_internal Stmt
%name pListIdent_internal ListIdent
%name pMatchClause_internal MatchClause
%name pExpr_internal Expr
%name pListMatchClause_internal ListMatchClause
%name pExpr8_internal Expr8
%token
  '!=' { PT _ (TS _ 1) }
  '(' { PT _ (TS _ 2) }
  ')' { PT _ (TS _ 3) }
  '*' { PT _ (TS _ 4) }
  '+' { PT _ (TS _ 5) }
  ',' { PT _ (TS _ 6) }
  '-' { PT _ (TS _ 7) }
  '->' { PT _ (TS _ 8) }
  '/' { PT _ (TS _ 9) }
  ':' { PT _ (TS _ 10) }
  '::' { PT _ (TS _ 11) }
  ';' { PT _ (TS _ 12) }
  '<' { PT _ (TS _ 13) }
  '<=' { PT _ (TS _ 14) }
  '=' { PT _ (TS _ 15) }
  '==' { PT _ (TS _ 16) }
  '>' { PT _ (TS _ 17) }
  '>=' { PT _ (TS _ 18) }
  '[' { PT _ (TS _ 19) }
  ']' { PT _ (TS _ 20) }
  'and' { PT _ (TS _ 21) }
  'as' { PT _ (TS _ 22) }
  'else' { PT _ (TS _ 23) }
  'false' { PT _ (TS _ 24) }
  'fun' { PT _ (TS _ 25) }
  'if' { PT _ (TS _ 26) }
  'match' { PT _ (TS _ 27) }
  'nil' { PT _ (TS _ 28) }
  'not' { PT _ (TS _ 29) }
  'or' { PT _ (TS _ 30) }
  'then' { PT _ (TS _ 31) }
  'true' { PT _ (TS _ 32) }
  'val' { PT _ (TS _ 33) }
  '{' { PT _ (TS _ 34) }
  '}' { PT _ (TS _ 35) }
  '~>' { PT _ (TS _ 36) }

  L_ident {PT _ (TV _)}
  L_integ {PT _ (TI _)}

%%

Ident :: {
  (Maybe (Int, Int), Ident)
}
: L_ident {
  (Just (tokenLineCol $1), Ident (prToken $1)) 
}

Integer :: {
  (Maybe (Int, Int), Integer)
}
: L_integ {
  (Just (tokenLineCol $1), read (prToken $1)) 
}

TypeName :: {
  (Maybe (Int, Int), TypeName (Maybe (Int, Int)))
}
: Ident {
  (fst $1, Language.Abs.TSimpleTypeName (fst $1)(snd $1)) 
}
| Ident '<' ListTypeName '>' {
  (fst $1, Language.Abs.TPolymorphicTypeName (fst $1)(snd $1)(snd $3)) 
}

ListTypeName :: {
  (Maybe (Int, Int), [TypeName (Maybe (Int, Int))]) 
}
: {
  (Nothing, [])
}
| TypeName {
  (fst $1, (:[]) (snd $1)) 
}
| TypeName ',' ListTypeName {
  (fst $1, (:) (snd $1)(snd $3)) 
}

Expr6 :: {
  (Maybe (Int, Int), Expr (Maybe (Int, Int)))
}
: Expr6 '+' Expr7 {
  (fst $1, Language.Abs.EAdd (fst $1)(snd $1)(snd $3)) 
}
| Expr6 '-' Expr7 {
  (fst $1, Language.Abs.ESub (fst $1)(snd $1)(snd $3)) 
}
| Expr7 {
  (fst $1, snd $1)
}

Expr7 :: {
  (Maybe (Int, Int), Expr (Maybe (Int, Int)))
}
: Expr7 '*' Expr8 {
  (fst $1, Language.Abs.EMul (fst $1)(snd $1)(snd $3)) 
}
| Expr7 '/' Expr8 {
  (fst $1, Language.Abs.EDiv (fst $1)(snd $1)(snd $3)) 
}
| 'not' Expr8 {
  (Just (tokenLineCol $1), Language.Abs.ENot (Just (tokenLineCol $1)) (snd $2)) 
}
| Expr8 {
  (fst $1, snd $1)
}

Expr5 :: {
  (Maybe (Int, Int), Expr (Maybe (Int, Int)))
}
: Expr5 '==' Expr6 {
  (fst $1, Language.Abs.EEq (fst $1)(snd $1)(snd $3)) 
}
| Expr5 '!=' Expr6 {
  (fst $1, Language.Abs.ENotEq (fst $1)(snd $1)(snd $3)) 
}
| Expr5 '<' Expr6 {
  (fst $1, Language.Abs.ELt (fst $1)(snd $1)(snd $3)) 
}
| Expr5 '>' Expr6 {
  (fst $1, Language.Abs.EGt (fst $1)(snd $1)(snd $3)) 
}
| Expr5 '<=' Expr6 {
  (fst $1, Language.Abs.ELtEq (fst $1)(snd $1)(snd $3)) 
}
| Expr5 '>=' Expr6 {
  (fst $1, Language.Abs.EGtEq (fst $1)(snd $1)(snd $3)) 
}
| '[' ListExpr ']' {
  (Just (tokenLineCol $1), Language.Abs.EList (Just (tokenLineCol $1)) (snd $2)) 
}
| 'nil' {
  (Just (tokenLineCol $1), Language.Abs.ENil (Just (tokenLineCol $1)))
}
| Expr6 {
  (fst $1, snd $1)
}

Expr10 :: {
  (Maybe (Int, Int), Expr (Maybe (Int, Int)))
}
: Integer {
  (fst $1, Language.Abs.EInt (fst $1)(snd $1)) 
}
| '-' Integer {
  (Just (tokenLineCol $1), Language.Abs.ENegInt (Just (tokenLineCol $1)) (snd $2)) 
}
| 'true' {
  (Just (tokenLineCol $1), Language.Abs.ETrue (Just (tokenLineCol $1)))
}
| 'false' {
  (Just (tokenLineCol $1), Language.Abs.EFalse (Just (tokenLineCol $1)))
}
| Ident {
  (fst $1, Language.Abs.EVar (fst $1)(snd $1)) 
}
| '(' Expr ')' {
  (Just (tokenLineCol $1), snd $2)
}

Expr2 :: {
  (Maybe (Int, Int), Expr (Maybe (Int, Int)))
}
: Expr2 'or' Expr5 {
  (fst $1, Language.Abs.EOr (fst $1)(snd $1)(snd $3)) 
}
| Expr2 'and' Expr5 {
  (fst $1, Language.Abs.EAnd (fst $1)(snd $1)(snd $3)) 
}
| Expr3 {
  (fst $1, snd $1)
}

FunctionParameter :: {
  (Maybe (Int, Int), FunctionParameter (Maybe (Int, Int)))
}
: Ident ':' TypeName {
  (fst $1, Language.Abs.AFunctionArgument (fst $1)(snd $1)(snd $3)) 
}

ListFunctionParameter :: {
  (Maybe (Int, Int), [FunctionParameter (Maybe (Int, Int))]) 
}
: {
  (Nothing, [])
}
| FunctionParameter {
  (fst $1, (:[]) (snd $1)) 
}
| FunctionParameter ',' ListFunctionParameter {
  (fst $1, (:) (snd $1)(snd $3)) 
}

Expr9 :: {
  (Maybe (Int, Int), Expr (Maybe (Int, Int)))
}
: '(' FunctionParameter '->' Expr ')' {
  (Just (tokenLineCol $1), Language.Abs.ELambda (Just (tokenLineCol $1)) (snd $2)(snd $4)) 
}
| Expr9 '(' ListExpr ')' {
  (fst $1, Language.Abs.EFunCall (fst $1)(snd $1)(snd $3)) 
}
| Expr10 {
  (fst $1, snd $1)
}

ListExpr :: {
  (Maybe (Int, Int), [Expr (Maybe (Int, Int))]) 
}
: {
  (Nothing, [])
}
| Expr {
  (fst $1, (:[]) (snd $1)) 
}
| Expr ',' ListExpr {
  (fst $1, (:) (snd $1)(snd $3)) 
}

Expr4 :: {
  (Maybe (Int, Int), Expr (Maybe (Int, Int)))
}
: Expr5 '::' Expr4 {
  (fst $1, Language.Abs.ECons (fst $1)(snd $1)(snd $3)) 
}
| Expr5 {
  (fst $1, snd $1)
}

Expr3 :: {
  (Maybe (Int, Int), Expr (Maybe (Int, Int)))
}
: 'if' Expr3 'then' Expr3 'else' Expr3 {
  (Just (tokenLineCol $1), Language.Abs.EIfte (Just (tokenLineCol $1)) (snd $2)(snd $4)(snd $6)) 
}
| Expr4 {
  (fst $1, snd $1)
}

Expr1 :: {
  (Maybe (Int, Int), Expr (Maybe (Int, Int)))
}
: Stmt ';' Expr1 {
  (fst $1, Language.Abs.ESemicolon (fst $1)(snd $1)(snd $3)) 
}
| Expr2 {
  (fst $1, snd $1)
}

Stmt :: {
  (Maybe (Int, Int), Stmt (Maybe (Int, Int)))
}
: 'val' Ident '=' Expr {
  (Just (tokenLineCol $1), Language.Abs.SDeclVar (Just (tokenLineCol $1)) (snd $2)(snd $4)) 
}
| 'fun' Ident '(' ListFunctionParameter ')' ':' TypeName '{' Expr '}' {
  (Just (tokenLineCol $1), Language.Abs.SDeclFun (Just (tokenLineCol $1)) (snd $2)(snd $4)(snd $7)(snd $9)) 
}

ListIdent :: {
  (Maybe (Int, Int), [Ident]) 
}
: {
  (Nothing, [])
}
| Ident {
  (fst $1, (:[]) (snd $1)) 
}
| Ident ',' ListIdent {
  (fst $1, (:) (snd $1)(snd $3)) 
}

MatchClause :: {
  (Maybe (Int, Int), MatchClause (Maybe (Int, Int)))
}
: 'as' Expr1 '~>' Expr2 {
  (Just (tokenLineCol $1), Language.Abs.MMatchClause (Just (tokenLineCol $1)) (snd $2)(snd $4)) 
}

Expr :: {
  (Maybe (Int, Int), Expr (Maybe (Int, Int)))
}
: 'match' Expr1 ListMatchClause {
  (Just (tokenLineCol $1), Language.Abs.EMatch (Just (tokenLineCol $1)) (snd $2)(reverse (snd $3)))
}
| Expr1 {
  (fst $1, snd $1)
}

ListMatchClause :: {
  (Maybe (Int, Int), [MatchClause (Maybe (Int, Int))]) 
}
: {
  (Nothing, [])
}
| ListMatchClause MatchClause {
  (fst $1, flip (:) (snd $1)(snd $2)) 
}

Expr8 :: {
  (Maybe (Int, Int), Expr (Maybe (Int, Int)))
}
: Expr9 {
  (fst $1, snd $1)
}

{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    t:_ -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens

pTypeName = (>>= return . snd) . pTypeName_internal
pListTypeName = (>>= return . snd) . pListTypeName_internal
pExpr6 = (>>= return . snd) . pExpr6_internal
pExpr7 = (>>= return . snd) . pExpr7_internal
pExpr5 = (>>= return . snd) . pExpr5_internal
pExpr10 = (>>= return . snd) . pExpr10_internal
pExpr2 = (>>= return . snd) . pExpr2_internal
pFunctionParameter = (>>= return . snd) . pFunctionParameter_internal
pListFunctionParameter = (>>= return . snd) . pListFunctionParameter_internal
pExpr9 = (>>= return . snd) . pExpr9_internal
pListExpr = (>>= return . snd) . pListExpr_internal
pExpr4 = (>>= return . snd) . pExpr4_internal
pExpr3 = (>>= return . snd) . pExpr3_internal
pExpr1 = (>>= return . snd) . pExpr1_internal
pStmt = (>>= return . snd) . pStmt_internal
pListIdent = (>>= return . snd) . pListIdent_internal
pMatchClause = (>>= return . snd) . pMatchClause_internal
pExpr = (>>= return . snd) . pExpr_internal
pListMatchClause = (>>= return . snd) . pListMatchClause_internal
pExpr8 = (>>= return . snd) . pExpr8_internal
}

