

module Language.Abs where

-- Haskell module generated by the BNF converter




newtype Ident = Ident String deriving (Eq, Ord, Show, Read)
data TypeName a
    = TSimpleTypeName a Ident
    | TPolymorphicTypeName a Ident [TypeName a]
  deriving (Eq, Ord, Show, Read)

instance Functor TypeName where
    fmap f x = case x of
        TSimpleTypeName a ident -> TSimpleTypeName (f a) ident
        TPolymorphicTypeName a ident typenames -> TPolymorphicTypeName (f a) ident (map (fmap f) typenames)
data FunctionParameter a = AFunctionArgument a Ident (TypeName a)
  deriving (Eq, Ord, Show, Read)

instance Functor FunctionParameter where
    fmap f x = case x of
        AFunctionArgument a ident typename -> AFunctionArgument (f a) ident (fmap f typename)
data Stmt a
    = SDeclVar a Ident (Expr a)
    | SDeclFun a Ident [FunctionParameter a] (TypeName a) (Expr a)
  deriving (Eq, Ord, Show, Read)

instance Functor Stmt where
    fmap f x = case x of
        SDeclVar a ident expr -> SDeclVar (f a) ident (fmap f expr)
        SDeclFun a ident functionparameters typename expr -> SDeclFun (f a) ident (map (fmap f) functionparameters) (fmap f typename) (fmap f expr)
data MatchClause a = MMatchClause a (Expr a) (Expr a)
  deriving (Eq, Ord, Show, Read)

instance Functor MatchClause where
    fmap f x = case x of
        MMatchClause a expr1 expr2 -> MMatchClause (f a) (fmap f expr1) (fmap f expr2)
data Expr a
    = EAdd a (Expr a) (Expr a)
    | ESub a (Expr a) (Expr a)
    | EMul a (Expr a) (Expr a)
    | EDiv a (Expr a) (Expr a)
    | EEq a (Expr a) (Expr a)
    | ENotEq a (Expr a) (Expr a)
    | ELt a (Expr a) (Expr a)
    | EGt a (Expr a) (Expr a)
    | ELtEq a (Expr a) (Expr a)
    | EGtEq a (Expr a) (Expr a)
    | EInt a Integer
    | ENegInt a Integer
    | EOr a (Expr a) (Expr a)
    | EAnd a (Expr a) (Expr a)
    | ENot a (Expr a)
    | ETrue a
    | EFalse a
    | ELambda a (FunctionParameter a) (Expr a)
    | EVar a Ident
    | EFunCall a (Expr a) [Expr a]
    | ECons a (Expr a) (Expr a)
    | EList a [Expr a]
    | ENil a
    | EIfte a (Expr a) (Expr a) (Expr a)
    | ESemicolon a (Stmt a) (Expr a)
    | EMatch a (Expr a) [MatchClause a]
  deriving (Eq, Ord, Show, Read)

instance Functor Expr where
    fmap f x = case x of
        EAdd a expr1 expr2 -> EAdd (f a) (fmap f expr1) (fmap f expr2)
        ESub a expr1 expr2 -> ESub (f a) (fmap f expr1) (fmap f expr2)
        EMul a expr1 expr2 -> EMul (f a) (fmap f expr1) (fmap f expr2)
        EDiv a expr1 expr2 -> EDiv (f a) (fmap f expr1) (fmap f expr2)
        EEq a expr1 expr2 -> EEq (f a) (fmap f expr1) (fmap f expr2)
        ENotEq a expr1 expr2 -> ENotEq (f a) (fmap f expr1) (fmap f expr2)
        ELt a expr1 expr2 -> ELt (f a) (fmap f expr1) (fmap f expr2)
        EGt a expr1 expr2 -> EGt (f a) (fmap f expr1) (fmap f expr2)
        ELtEq a expr1 expr2 -> ELtEq (f a) (fmap f expr1) (fmap f expr2)
        EGtEq a expr1 expr2 -> EGtEq (f a) (fmap f expr1) (fmap f expr2)
        EInt a integer -> EInt (f a) integer
        ENegInt a integer -> ENegInt (f a) integer
        EOr a expr1 expr2 -> EOr (f a) (fmap f expr1) (fmap f expr2)
        EAnd a expr1 expr2 -> EAnd (f a) (fmap f expr1) (fmap f expr2)
        ENot a expr -> ENot (f a) (fmap f expr)
        ETrue a -> ETrue (f a)
        EFalse a -> EFalse (f a)
        ELambda a functionparameter expr -> ELambda (f a) (fmap f functionparameter) (fmap f expr)
        EVar a ident -> EVar (f a) ident
        EFunCall a expr exprs -> EFunCall (f a) (fmap f expr) (map (fmap f) exprs)
        ECons a expr1 expr2 -> ECons (f a) (fmap f expr1) (fmap f expr2)
        EList a exprs -> EList (f a) (map (fmap f) exprs)
        ENil a -> ENil (f a)
        EIfte a expr1 expr2 expr3 -> EIfte (f a) (fmap f expr1) (fmap f expr2) (fmap f expr3)
        ESemicolon a stmt expr -> ESemicolon (f a) (fmap f stmt) (fmap f expr)
        EMatch a expr matchclauses -> EMatch (f a) (fmap f expr) (map (fmap f) matchclauses)
